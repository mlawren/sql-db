
=head1 NAME

SQL::DB - SQL database interface for Perl

=head1 VERSION

0.19_10. Development release.

=head1 SYNOPSIS

    use SQL::DB ':all';

    my $db = SQL::DB->connect($dsn, $username, $password);

    my $people = $db->irow('people');

    $db->do(
        insert_into => $people->('id','name');
        sql_values(1, 'A Name'),
    );

    # Anyone celebrating a birthday today gets a raise, with the
    # calculation done inside the database.

    my $people = $db->urow('people');

    $db->do(
        update => $people,
        set    => $people->salary( $people->salary * 2 ),
        where  => $people->dob == $today,
    );

    my $purchases = $db->srow('purchases');

    my $row = $db->fetch1(
        select    => [ $people->name, $ps->pid ],
        from      => $people,
        left_join => $purchases,
        on        => $purchases->id == $people->id,
        where     => $people->id->in(1,2,3) .AND.
                       $people->name->like('%paul%'),
        limit  => 1,
        offset => 1,
    );
    # then do stuff with $row->pid, $row->name etc

    my @rows = $db->fetch(
        select => [ sql_coalesce($p->pid, $p->cid)->as('pcid') ],
        from   => $p,
        where  => $p->cid->is_not_null,
    );
    # coalesce column is available as $row->pcid

    my $iter = $db->iter( @query ...);
    while (my $row = $iter->next) {
        print $row->column(), $row->some_other_column;
    }

    # If you want the data your own way you can still use the query
    # syntax:
    my $sth = $db->sth( @query);
    map { print join(',',@$_) ."\n" } $sth->fetchall_arrayref;

    # Transactions provided by DBIx::Connector
    $db->txn( sub {
        # multiple statements
    });


=head1 DESCRIPTION

B<SQL::DB> is an extension to the Perl Database Interface (L<DBI>).  It
is designed for complicated queries and efficient access to results.
With an API that lets you easily write almost-raw SQL, SQL::DB gives
you unfettered access to the power and flexibility of your underlying
database. It aims to be a tool for programmers who want their databases
to work just as hard as their Perl scripts.

SQL::DB gives you access to aggregate expressions, joins, nested
selects, unions and database-side operator invocations. Transactional
support is provided via L<DBIx::Connector>. Binding non-integer
non-string (eg binary) data types is handled transparently across
different database types. For more basic needs you might consider
starting with the L<SQL::DBx::Simple> extension.

Although rows can be retrieved from the database as simple objects,
SQL::DB does not attempt to be an Object-Relational-Mapper (ORM). There
are no auto-inflating columns or automatic joins and the code size and
speed reflect the lack of complexity.

SQL::DB uses the light-weight L<Log::Any> for logging.

=head1 QUERY FORMAT

An L<SQL::DB> query is composed from a list of scalars, schema objects,
expressions, and arrays as follows.

=over 4

=item Scalars

Scalars are assumed to be SQL keywords and are accepted more or less
unchanged (uppercased with underscores converted to spaces).

    Perl                            SQL
    ----                            ---
    'select'                        SELECT
    'outer_join'                    OUTER JOIN

=item Schema Objects

and DELETE.  A urow object maps to a table in the database. It has a
method for each of the columns in the table which return
column-objects. These column-objects in turn have further methods which
map to various SQL statements. The table and column objects are used in
positions as appropriate for their types.

    Perl                            SQL
    ----                            ---
    $table                          table  (for UPDATE statements)
    $table                          table0 (for SELECT statements)
    $table->col > 1                 table0.col > ?
    $table->col->is_not_null        table0.col IS NULL
    $table->col->asc                table0.col ASC
    $table->col->between(1,5)       table0.col BETWEEN(?,?)

=item Expressions

Expressions are built using schema objects (described below) that hold
extra information such as table/column names and types, your
application's input values, and their relationships.

    Perl                            SQL
    ----                            ---
    $table->col == 1                table0.col = ?

    ($table->col == 1) .AND.
      ($table.col2 = ?
    $table->col > 1                 table0.col > ?

    $table->col ==                  table.col =
      $table->col2 - $table->col3     table.col2 - table.col3 

=item Arrays

Arrays (array-refs) can contain scalars and expressions which will
appear in the final SQL joined together by commas (',').

    Perl                                    SQL
    ----                                    ---
    select => [1,2,3]                       SELECT ?,?,?
    set => [$t->c1 == 1, $t->c2 == 2 ]      SET t->c1 = ?, t.c2 = ?

=item Functions

Arrays (array-refs) can contain scalars and expressions which will
appear in the final SQL joined together by commas (',').

    Perl                                SQL
    ----                                ---
    sql_count($table->col)              COUNT(table0.col)
    sql_values('a', 'b', 'c')           VALUES(?,?,?)

=back


=head1 CONSTRUCTORS

=over 4

=item new( %args )

Connect to a database and return a new SQL::DB handle. Arguments are as
follows:

=over 4

=item dsn

The data source name ('dbi:...'). Required.

=item username

The database authentication username.

=item password

The database authentication password.

=item attr

A hash-reference of L<DBI> handle attributes.  RaiseError and
AutoCommit are always set to 1 and cannot be overridden.  PrintError
defaults to 0.  ChopBlanks defaults to 1. pg_enable_utf8,
sqlite_unicode, and mysql_enable_utf8 default to 1.

=item cache_sth

Whether to use the L<DBI> prepare_cached() method. See ATTRIBUTES
below.

=item schema

The name of the schema class (less the '::Driver' part) associated with
this handle. See the command-line tool L<sqldb-schema>(1) for details.

=back


=item connect( $dsn, [ $username, $password, $attr ] )

This is a convenience wrapper around new() for those who prefer
L<DBI>-style construction.

=back

=head1 ATTRIBUTES

=over 4

=item conn -> L<DBIx::Connector>

The handle connecting us to the database. Read-only.

=item dbd -> Str

The database driver name (Pg, SQLite, etc). Read-only.

=item schema -> L<SQL::DB::Schema>

The schema definition associated with this connection. Read-only.

=item cache_sth <-> Bool

If true then the L<DBI> prepare_cached() method will be used for
creating statement handles. Otherwise prepare() will be used.

=back

=head1 METHODS

=over 4

=item irow( @tables ) -> @coderef

Returns coderefs for generating table/column strings.  In scalar
context returns a single coderef. Calling the coderef with column name
arguments returns a string of the form 'table(col1,col2)'.

These refs can be used with the do() method for INSERT queries.

=item urow( @tables ) -> @URow

Returns schema objects representing database tables/rows for
update-style SQL. In scalar context returns a single object.

These objects have a method for each table column.  Each column object
has the following methods: is_null(), is_not_null(), in(), not_in(),
between(), not_between(), as(), like(), asc(), and desc() (see
L<SQL::DB::Expr> for details).

These objects can be used with the do() method for UPDATE and DELETE
queries.

=item srow( @tables ) -> @SRow

Returns schema objects representing database tables/rows for
select-style SQL. In scalar context returns a single object.

These objects have a method for each table column.  Each column object
has the following methods: is_null(), is_not_null(), in(), not_in(),
between(), not_between(), as(), like(), asc(), and desc() (see
L<SQL::DB::Expr> for details).

These objects can be used with the do(), sth(), fetch(), fetch1(), and
iter() methods for SELECT queries.

=item prepare( @query ) -> ($sth, $query)

Prepares @query using L<DBI> prepare() and returns a L<DBI::st>
statement handle and the L<SQL::DB::Expr> object representing the
query. Croaks on error.

You need to call execute() on the statement handle yourself afterwards.

=item prepare_cached( @query ) -> ($sth, $query)

Prepares @query using L<DBI> prepare_cached() and returns a L<DBI::st>
statement handle and the L<SQL::DB::Expr> object representing the
query. Croaks on error.

You need to call execute() on the statement handle yourself afterwards.

=item do(@query) -> $count

Prepares (a INSERT, UPDATE or DELETE) @query using either prepare() or
prepare_cached() (depending on the "cache_sth" attribute) and
execute()'s the associated L<DBI::st> statement handle. Croaks on
error.

Returns the value of the execute() call. The result is typically the
number of rows affected (but this is driver dependent).

=item sth( @query ) -> DBI::st

Prepares (a SELECT) @query using either prepare() or prepare_cached()
(depending on the "cache_sth" attribute) then execute()s and returns
the associated L<DBI::st> statement handle. Croaks on error.

This method is useful if you want to obtain the data with one of the
L<DBI> fetchrow_hashref(), fetchall_arrayref() etc methods.

=item fetch(@query) -> @rows

Prepares (a SELECT) @query using either prepare() or prepare_cached()
(depending on the "cache_sth" attribute) and execute()'s it. Croaks on
error.

Returns a list of array-based objects and closes the underlying
statement handle. Each object has accessor methods for each column
selected.

Be aware that calling this method can consume large amounts of memory
if there are lots of rows to be retrieved. Consider using iter()
instead.

=item fetch1(@query) -> $row

Prepares (a SELECT) @query using either prepare() or prepare_cached()
(depending on the "cache_sth" attribute) and execute()'s it. Croaks on
error.

Returns a single array-based object and closes the underlying statement
handle.  The object has accessor methods for each column selected.

=item iter( @query ) -> L<SQL::DB::Iter>

Prepares (a SELECT) @query using either prepare() or prepare_cached()
(depending on the "cache_sth" attribute) and execute()'s it. Croaks on
error.

Returns a cursor/iteration object with next() and all() methods for
retrieving array-based objects. Each object has accessor methods for
each column selected.

=item txn(&coderef)

Runs the Perl code in &coderef as an SQL transaction. If &coderef does
not raise any exceptions then the transaction is commited, otherwise it
is rolled back. See L<DBIx::Connector> for details.

=item current_timestamp -> Str

Returns the current UTC timestamp as a string in the form 'yyyy-mm-dd
hh:mm:ss'.  The returned value remains constant during a transaction.

=item query_as_string($sql, @bind_values) -> Str

Pretty print an SQL query by inserting the bind values into the SQL
itself.

=back

=head1 CLASS FUNCTIONS

The following functions can be exported individually or all at once
using the ':all' tag.  They all return an object which can be combined
with or used inside other functions.

=over 4

=item bv( $value, [ $bind_type ] ) -> L<SQL::DB::BindValue>

This function returns an object which tells SQL::DB to bind $value
using a placeholder. The optional $bind_type is a database type
(integer, varchar, timestamp, bytea, etc) which will be converted to
the appropriate bind constant during a prepare() or prepare_cached()
call.

=item query( @query ) -> L<SQL::DB::Expr>

Build an SQL query using a list of scalars, schema objects,
expressions, other functions, and arrays. This function is the basis
for the prepare(), prepare_cached(), do(), sth(), iter(), fetch() and
fetch1() methods.

=item sql_and( @args ) -> L<SQL::DB::Expr>

Maps to "$arg1 AND $arg2 AND ...".

=item sql_case( @stmts ) -> L<SQL::DB::Expr>

Wraps @stmts inside a CASE/END pair while converting arguments to
expressions where needed.

    sql_case(
        when => $actors->name->is_null,
        then => 'No Name',
        else => $actors->name,
    )->as('name')

    # CASE WHEN actors0.name IS NULL
    # THEN ? ELSE actors0.name END AS name

=item sql_coalesce(@args) -> L<SQL::DB::Expr>

Maps to "COALESCE($arg1, $arg2, ...)".

=item sql_cast($arg1, as => $arg2) -> L<SQL::DB::Expr>

Maps to "CAST( $arg1 AS $arg2 )".

=item sql_concat(@args) -> L<SQL::DB::Expr>

Maps to "$arg1 || $arg2 || ...".

=item sql_count(@args) -> L<SQL::DB::Expr>

Maps to "COUNT($arg1, $arg2, ...)".

=item sql_exists(@args) -> L<SQL::DB::Expr>

Maps to "EXISTS(@args)".

=item sql_func('myfunc', @args) -> L<SQL::DB::Expr>

Maps to "MYFUNC($arg1, $arg2, ...)".

=item sql_length(@args) -> L<SQL::DB::Expr>

Maps to "LENGTH(@args)".

=item sql_lower(@args) -> L<SQL::DB::Expr>

Maps to "LOWER(@args)".

=item sql_ltrim(@args) -> L<SQL::DB::Expr>

Maps to "LTRIM(@args)".

=item sql_max(@args) -> L<SQL::DB::Expr>

Maps to "MAX(@args)".

=item sql_min(@args) -> L<SQL::DB::Expr>

Maps to "MIN(@args)".

=item sql_rtrim(@args) -> L<SQL::DB::Expr>

Maps to "RTRIM(@args)".

=item sql_sum(@args) -> L<SQL::DB::Expr>

Maps to "MIN(@args)".

=item sql_or(@args) -> L<SQL::DB::Expr>

Maps to "$arg1 OR $arg2 OR ...".

=item sql_replace(@args) -> L<SQL::DB::Expr>

Maps to "REPLACE($arg1,$arg2 [,$arg3])".

=item sql_substr(@args) -> L<SQL::DB::Expr>

Maps to "SUBSTR($arg1, $arg2, ...)".

=item sql_table($name, @columns) -> L<SQL::DB::Expr>

Maps to "name(col1,col2,...)".

=item sql_upper(@args) -> L<SQL::DB::Expr>

Maps to "UPPER(@args)".

=item sql_values(@args) -> L<SQL::DB::Expr>

Maps to "VALUES($arg1, $arg2, ...)".

=back

=head1 COMPATABILITY

All SQL::DB releases have so far been DEVELOPMENT!

SQL::DB jumped from version 0.18 to 0.98 due to a complete rewrite
based on Moo. Lots of things were simplified, modules deleted,
dependencies removed, etc. The API changed enough to almost give this
distribution a new name, except I don't know of anyone using this apart
from myself. 0.98 will be the last release marked as development, 0.99
will be a release candidate, and 1.00 will be the first stable release.

=head1 SEE ALSO

L<DBIx::Connector>, L<Log::Any>

=head1 SUPPORT

Feedback, testing, bug reports and patches are all welcome.

=over

=item Bug Reporting

    https://rt.cpan.org/Public/Bug/Report.html?Queue=SQL-DB

=item Source Code

    git clone git://github.com/mlawren/sql-db.git

=back

=head1 AUTHOR

Mark Lawrence E<lt>nomad@null.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2007-2011 Mark Lawrence <nomad@null.net>

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

